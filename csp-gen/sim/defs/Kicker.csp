
--
-- RoboSim generator version 3.0.0.202302061258
-- Automatically generated on 14-06-2023 19:09:34
--

module Kicker
exports

	transparent dbisim
	transparent sbisim
	transparent chase

	-- declaring channels
	-- allInputs = inputs_evars? false
	-- allOutputs = outputs_evars? false
	
	-- inputs, evars, rvars and outputs as calculated internally
	-- outputs = {
	--	(Kicker::kicked,stm_ref0::kicked),
	--	(Kicker::doKick,stm_ref0::doKick),
	--	(Kicker::doMove,stm_ref0::doMove),
	--	(Kicker::doDribble,stm_ref0::doDribble),
	--	(Kicker::canKickToGoal,stm_ref0::canKickToGoal),
	--	(Kicker::ball,stm_ref0::ball),
	--	(Kicker::stop,stm_ref0::stop),
	--	(Kicker::kickable,stm_ref0::kickable)
	--	 }
	-- inputs = {
	--	(Kicker::kicked,stm_ref0::kicked),
	--	(Kicker::updateWorldModel,stm_ref0::updateWorldModel),
	--	(Kicker::ball,stm_ref0::ball),
	--	(Kicker::kickable,stm_ref0::kickable)
	--	 }
	-- evars = {}
	-- dvars = {}
	
	-- declaring registerRead/Write datatypes
	datatype RegisterDataInput = i_kicked.core_boolean
		| i_updateWorldModel.Bool
		| i_ball.Point
		| i_kickable.core_boolean
	
	datatype RegisterDataOutput = o_stop
		| o_kicked.core_boolean
		| o_doDribble
		| o_updateWorldModel
		| o_canKickToGoal
		| o_doMove.Point
		| o_ball.Point
		| o_kickable.core_boolean
		| o_doKick
	
	
	nametype RegisterOutputs = {|
	o_kicked,
	o_doKick,
	o_doMove,
	o_doDribble,
	o_canKickToGoal,
	o_ball,
	o_stop,
	o_kickable|}
		
	nametype RegisterInputs = {|
	i_kicked,
	i_updateWorldModel,
	i_ball,
	i_kickable|}
	
	channel registerRead 	: RegisterDataInput
	channel registerWrite 	: RegisterDataOutput
	
	channel endexec, terminate
	
	
	-- declaring call and ret events for undefined operations
	channel doDribbleCall
	channel canKickToGoalCall
	channel doKickCall
	channel doMoveCall: Point
	channel stopCall
	
	-- channel set with all visible events
	sem__events = {|endexec,terminate
	,registerRead
	,registerWrite
	|}
	
	module stm_ref0
	exports
		transparent diamond
		transparent sbisim
		transparent dbisim
		transparent chase
	
		-- Transition identifiers
		-- declaring identifiers of transitions
		datatype NIDS = 
		              NID_i0|
		              NID_f0|
		              NID_SGoToBall|
		              NID_DMovingToBall|
		              NID_j0|
		              NID_SKick|
		              NID_DKicking|
		              NID_j1|
		              NID_SDribble|
		              NID_j2
		
		channel internal__ : NIDS
		
		-- Flow channels		
		channel interrupt
		channel exited
		channel exit
		channel terminate
		
		-- Variable channels
		channel get_ball, set_ball, setL_ball, setR_ball: Point
		channel get_kickable, set_kickable, setL_kickable, setR_kickable: core_boolean
		channel get_kicked, set_kicked, setL_kicked, setR_kicked: core_boolean
		
		-- Shared variable channels
		channel set_EXT_ball: Point
		channel set_EXT_kickable: core_boolean
		channel set_EXT_kicked: core_boolean
		
		-- Local variable channels for defined operations that are required by the state machine
		
		-- Declaring state machine events
		
		-- Declaring call and ret events for undefined operations
		channel doDribbleCall
		channel canKickToGoalCall
		channel doKickCall
		channel doMoveCall: Point
		channel stopCall
		
		enterSS = {|
		i0::enter,
		f0::enter,
		SGoToBall::enter,
		DMovingToBall::enter,
		j0::enter,
		SKick::enter,
		DKicking::enter,
		j1::enter,
		SDribble::enter,
		j2::enter
		|}
		
		enteredSS = 	{|
		f0::entered,
		SGoToBall::entered,
		DMovingToBall::entered,
		SKick::entered,
		DKicking::entered,
		SDribble::entered
		|}
		
		internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
		
		shared_variable_events = {|
			set_EXT_ball,
			set_EXT_kickable,
			set_EXT_kicked
		|}
		
		
		channel clockReset, clockResetL, clockResetR 
		
		localClockResets = {||}
		
		
		channel get_CLID_SGoToBall : core_clock_type 
		channel get_CLID_SKick : core_clock_type 
		channel get_CLID_DMovingToBall : core_clock_type 
		channel get_CLID_SDribble : core_clock_type 
		channel get_CLID_f0 : core_clock_type 
		channel get_CLID_DKicking : core_clock_type 
		--channel increment__
		
		CLID_SGoToBall_clock_type(id__) = 
			let
				max = (clock_type_max(Union({
		{}
		}))+1)
			ctype = {0..max}
		within
			if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
		
		CLID_SKick_clock_type(id__) = 
			let
				max = (clock_type_max(Union({
		{}
		}))+1)
			ctype = {0..max}
		within
			if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
		
		CLID_DMovingToBall_clock_type(id__) = 
			let
				max = (clock_type_max(Union({
		{}
		}))+1)
			ctype = {0..max}
		within
			if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
		
		CLID_SDribble_clock_type(id__) = 
			let
				max = (clock_type_max(Union({
		{}
		}))+1)
			ctype = {0..max}
		within
			if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
		
		CLID_f0_clock_type(id__) = 
			let
				max = (clock_type_max(Union({
		{}
		}))+1)
			ctype = {0..max}
		within
			if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
		
		CLID_DKicking_clock_type(id__) = 
			let
				max = (clock_type_max(Union({
		{}
		}))+1)
			ctype = {0..max}
		within
			if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
		
		
		
		-- RoboSim-specific declarations
		channel endexec, endexec_action
		channel endexec__ : NIDS
		channel startexec, startexec_action
		
		-- declaring registerRead/Write datatypes
		datatype RegisterDataInput = i_kickable.core_boolean
			| i_ball.Point
			| i_updateWorldModel.Bool
		
		
		datatype RegisterDataOutput = o_doKick
			| o_stop
			| o_doMove.Point
			| o_doDribble
			| o_canKickToGoal
			| o_kicked.core_boolean
		
		
		nametype RegisterOutputs = {|
		o_doKick,
		o_stop,
		o_doMove,
		o_doDribble,
		o_canKickToGoal,
		o_kicked|}
			
		nametype RegisterInputs = {|
		i_kickable,
		i_ball,
		i_updateWorldModel|}
		
		channel registerRead 	: RegisterDataInput
		channel registerWrite 	: RegisterDataOutput
		
		-- variable channels
		channel get_updateWorldModel : Bool
		
		-- channel set with all visible events
		sem__events = {|endexec,terminate
					,registerRead
					,registerWrite
		,	doDribbleCall,
			canKickToGoalCall,
			doKickCall,
			doMoveCall,
			stopCall
			|}
	
			-- Nodes --
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: i0
			module i0
			exports
			
				channel enter, interrupt
				
				Timed(OneStep) {
					D__(id__,cycle_KickerStm_KickerStm) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,cycle_KickerStm_KickerStm) = D__(id__,cycle_KickerStm_KickerStm)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: f0
			module f0
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					D__(id__,cycle_KickerStm_KickerStm) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = D__(id__,cycle_KickerStm_KickerStm)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: SGoToBall
			module SGoToBall
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				channel endexec__ : NIDS
				
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(get_ball?ball -> true&CALL__doMove(
									id__,
									ball
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(get_ball?ball -> true&CALL__doMove(
									id__,
									ball
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: DMovingToBall
			module DMovingToBall
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				channel endexec__ : NIDS
				
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Junction: j0
			module j0
			exports
			
				channel enter, interrupt
				
				Timed(OneStep) {
					D__(id__,cycle_KickerStm_KickerStm) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = D__(id__,cycle_KickerStm_KickerStm)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: SKick
			module SKick
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				channel endexec__ : NIDS
				
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__doKick(
									id__
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__doKick(
									id__
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: DKicking
			module DKicking
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				channel endexec__ : NIDS
				
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Junction: j1
			module j1
			exports
			
				channel enter, interrupt
				
				Timed(OneStep) {
					D__(id__,cycle_KickerStm_KickerStm) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = D__(id__,cycle_KickerStm_KickerStm)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: SDribble
			module SDribble
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				channel endexec__ : NIDS
				
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__doDribble(
									id__
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__doDribble(
									id__
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Junction: j2
			module j2
			exports
			
				channel enter, interrupt
				
				Timed(OneStep) {
					D__(id__,cycle_KickerStm_KickerStm) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,cycle_KickerStm_KickerStm) = D__(id__,cycle_KickerStm_KickerStm)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			-- END of Nodes --
			
			Timed(OneStep) {
			-- Operation calls --
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machine module.
			CALL__doDribble(id__) = EDeadline(registerWrite.o_doDribble,0)
			CALL__canKickToGoal(id__) = EDeadline(registerWrite.o_canKickToGoal,0)
			CALL__doKick(id__) = EDeadline(registerWrite.o_doKick,0)
			CALL__doMove(id__,
						param_pos) = EDeadline(registerWrite.o_doMove.param_pos,0)
			CALL__stop(id__) = EDeadline(registerWrite.o_stop,0)
			
			-- END of Operation calls --
		
			datatype SOutputEvents = SOutput_doKick
				| SOutput_stop
				| SOutput_doMove
				| SOutput_doDribble
				| SOutput_canKickToGoal
				| SOutput_kicked
			
			cycle(cycle_KickerStm_KickerStm) =
				let
					project(o_doKick) = SOutput_doKick
					project(o_stop) = SOutput_stop
					project(o_doMove.x__) = SOutput_doMove
					project(o_doDribble) = SOutput_doDribble
					project(o_canKickToGoal) = SOutput_canKickToGoal
					project(o_kicked.x__) = SOutput_kicked
			
					Cycle =
						Deadline(
							(registerRead.i_kickable?x__ -> SKIP
								||| registerRead.i_ball?x__ -> SKIP
								||| registerRead.i_updateWorldModel?x__ -> SKIP);
							startexec -> CollectOutputs(SOutputEvents),0);
						TimeOut_1(terminate -> SKIP,WAIT(cycle_KickerStm_KickerStm-1);Cycle)
					
					CollectOutputs(sout) =
						(registerWrite?outp:{ outp | outc <- inter(sout,SOutputEvents), outp <- RegisterDataOutput,project(outp) == outc} -> CollectOutputs(diff(sout,{project(outp)}))
							[]
						endexec -> SKIP
						)
				within
					Cycle
			
			-- STM processes
			STM(id__,cycle_KickerStm_KickerStm) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			(
				cycle(cycle_KickerStm_KickerStm)
				[| {| endexec,registerRead,registerWrite,startexec,terminate |} |]
				( 
					(
						(
							(startexec -> IteratedStateful(id__,cycle_KickerStm_KickerStm) \ {terminate}) 
							[| {share__} |]
							SKIP
						) ; 
						(let
							Ending = endexec -> (startexec -> Ending [] terminate -> SKIP)
						 within
						 	Ending
						)
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,cycle_KickerStm_KickerStm))
				)\sharedVarHide
			)\{startexec}
			
			STM_VS_O(id__,cycle_KickerStm_KickerStm) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			(
				cycle(cycle_KickerStm_KickerStm)
				[| {| endexec,registerRead,registerWrite,startexec,terminate |} |]
				( 
					(
						(
							(startexec -> IteratedStateful_VS_O(id__,cycle_KickerStm_KickerStm) \ {terminate}) 
							[| {share__} |]
							SKIP
						) ; 
						(let
							Ending = endexec -> (startexec -> Ending [] terminate -> SKIP)
						 within
						 	Ending
						)
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,cycle_KickerStm_KickerStm))
				)\sharedVarHide
			)\{startexec}
			
			-- Transitions
			Transitions(id__,cycle_KickerStm_KickerStm) = ((let
				Trans = share__choice(get_kickable?kickable -> TimeOut_1(
					 (share__ -> SKIP
					 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; SGoToBall::enter -> SKIP))))
					 [] dbisim((true)&(internal__!NID_SGoToBall -> SKIP ;  share__choice(exit -> SKIP) ; ((let 
					 	X = share__choice(exited -> SKIP [] endexec -> Y)
					 	Y = share__choice(exited -> SKIP [] startexec -> X)
					  within
					  	X) ; ((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; DMovingToBall::enter -> SKIP)))
					 [] dbisim((true)&(endexec__.NID_DMovingToBall -> startexec_action -> SKIP ;  share__choice(exit -> SKIP) ; ((let 
					 	X = share__choice(exited -> SKIP [] endexec -> Y)
					 	Y = share__choice(exited -> SKIP [] startexec -> X)
					  within
					  	X) ; ((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; j0::enter -> SKIP)))
					 [] dbisim(((not (kickable)))&(internal__!NID_j0 -> SKIP ;  ((((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; DMovingToBall::enter -> SKIP))))
					 [] dbisim((kickable)&(internal__!NID_j0 -> SKIP ;  ((((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; SKick::enter -> SKIP))))
					 [] dbisim((true)&(internal__!NID_SKick -> SKIP ;  share__choice(exit -> SKIP) ; ((let 
					 	X = share__choice(exited -> SKIP [] endexec -> Y)
					 	Y = share__choice(exited -> SKIP [] startexec -> X)
					  within
					  	X) ; ((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; DKicking::enter -> SKIP)))
					 [] dbisim((true)&(endexec__.NID_DKicking -> startexec_action -> SKIP ;  share__choice(exit -> SKIP) ; ((let 
					 	X = share__choice(exited -> SKIP [] endexec -> Y)
					 	Y = share__choice(exited -> SKIP [] startexec -> X)
					  within
					  	X) ; ((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; j1::enter -> SKIP)))
					 [] dbisim((true)&(internal__!NID_j1 -> SKIP ;  ((((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; f0::enter -> SKIP))))
					 [] dbisim((true)&(internal__!NID_j1 -> SKIP ;  ((((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; SDribble::enter -> SKIP))))
					 [] dbisim((true)&(endexec__.NID_SDribble -> startexec_action -> SKIP ;  share__choice(exit -> SKIP) ; ((let 
					 	X = share__choice(exited -> SKIP [] endexec -> Y)
					 	Y = share__choice(exited -> SKIP [] startexec -> X)
					  within
					  	X) ; ((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; j2::enter -> SKIP)))
					 [] dbisim((true)&(internal__!NID_j2 -> SKIP ;  ((((SKIP)[[ endexec <- endexec_action, startexec <- startexec_action ]]) ; SGoToBall::enter -> SKIP))))
					 []
					 (exit -> SKIP ; share__choice(exited -> terminate -> SKIP))
					 []
					 terminate -> SKIP
					 []
					 (endexec -> SKIP ; share__choice(startexec -> SKIP))
					 )
				,SKIP);Trans
				)
			within
				Trans [|{terminate}|> SKIP
			)
			)
			
			-- Stateful
			-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
			
			-- Named process definitions
			MachineBody(id__,cycle_KickerStm_KickerStm) = 
				dbisim((
				let
					finalNodesEntered = {|f0::entered|}
				within
					(dbisim((dbisim((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						i0::enter,
						f0::enter,
						SGoToBall::enter,
						DMovingToBall::enter,
						j0::enter,
						SKick::enter,
						DKicking::enter,
						j1::enter,
						SDribble::enter,
						j2::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited|})
							transSync = {|internal__.NID_i0,internal__.NID_SGoToBall,endexec__.NID_DMovingToBall,internal__.NID_j0,internal__.NID_j0,internal__.NID_SKick,endexec__.NID_DKicking,internal__.NID_j1,internal__.NID_j1,endexec__.NID_SDribble,internal__.NID_j2|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   i0::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   f0::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   SGoToBall::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   DMovingToBall::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   j0::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   SKick::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   DKicking::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   j1::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   SDribble::D__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   j2::D__(id__,cycle_KickerStm_KickerStm)
							   )
							   )
							   )
							   )
							   )
							   )
							   )
							   )
							   )
							 )
							 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[SGoToBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SGoToBall|}]]
							 [[DMovingToBall::interrupt <- x__ | x__ <- {|interrupt,endexec__.NID_DMovingToBall|}]]
							 [[SKick::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SKick|}]]
							 [[DKicking::interrupt <- x__ | x__ <- {|interrupt,endexec__.NID_DKicking|}]]
							 [[SDribble::interrupt <- x__ | x__ <- {|interrupt,endexec__.NID_SDribble|}]]
							 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
							 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
							 [[j1::interrupt <- x__ | x__ <- {|internal__.NID_j1,internal__.NID_j1|}]]
							 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_kickable <- setL_kickable]]
							 )
							 [| union(union(union(flowevts,transSync),{|terminate,endexec,startexec|}),{|share__
							 			,setL_kickable
							|}) |]
							 ((i0::enter -> Transitions(id__,cycle_KickerStm_KickerStm))
							  [[ share__ <- x__ | x__ <- {| share__,setL_kickable |} ]]
							 )
							)[[setL_kickable <- set_kickable]]
							)
						)
						 \ hideSet)
						[[ endexec__.x____  <- endexec | x____ <- NIDS ]]
						[[ endexec_action <- endexec ]]
						[[ startexec_action <- startexec ]]
					)
					)
					 [| union(stateClockSync,{terminate}) |]
					 StateClocks(id__)
					)\diff(stateClockSync,enteredSS))
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour(id__,cycle_KickerStm_KickerStm) = 
				dbisim((let
					stateClockSync = {|get_CLID_SGoToBall,SGoToBall::entered,get_CLID_SKick,SKick::entered,get_CLID_DMovingToBall,DMovingToBall::entered,get_CLID_SDribble,SDribble::entered,get_CLID_DKicking,DKicking::entered|}
				 within
					(MachineBody(id__,cycle_KickerStm_KickerStm) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
				)
				)
			
			IteratedBehaviour(id__,cycle_KickerStm_KickerStm) = 
				dbisim((let
					stateClockSync = {|get_CLID_SGoToBall,SGoToBall::entered,get_CLID_SKick,SKick::entered,get_CLID_DMovingToBall,DMovingToBall::entered,get_CLID_SDribble,SDribble::entered,get_CLID_DKicking,DKicking::entered|}
				 within
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__,cycle_KickerStm_KickerStm)
															[| {|get_CLID_DKicking,DKicking::entered,terminate|} |]
															dbisim(Clock_CLID_DKicking(id__,0))
														)\{|get_CLID_DKicking|}
													)
													[| {|get_CLID_SDribble,SDribble::entered,terminate|} |]
													dbisim(Clock_CLID_SDribble(id__,0))
												)\{|get_CLID_SDribble|}
											)
											[| {|get_CLID_DMovingToBall,DMovingToBall::entered,terminate|} |]
											dbisim(Clock_CLID_DMovingToBall(id__,0))
										)\{|get_CLID_DMovingToBall|}
									)
									[| {|get_CLID_SKick,SKick::entered,terminate|} |]
									dbisim(Clock_CLID_SKick(id__,0))
								)\{|get_CLID_SKick|}
							)
							[| {|get_CLID_SGoToBall,SGoToBall::entered,terminate|} |]
							dbisim(Clock_CLID_SGoToBall(id__,0))
						)\{|get_CLID_SGoToBall|}
					)
					) \ union(stateClockSync,enteredSS)
				)
				)
			
			Stateful(id__,cycle_KickerStm_KickerStm) = 
				((let
					getsetLocalChannels = {||}
					clockSync = {||}
				within
					(Behaviour(id__,cycle_KickerStm_KickerStm) 
					 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
					 (varMemory(id__,cycle_KickerStm_KickerStm) [| {terminate} |] Clocks(id__))
				 	)\union(getsetLocalChannels,clockSync)
				)
				)
			
			IteratedStateful(id__,cycle_KickerStm_KickerStm) =
				(IteratedBehaviour(id__,cycle_KickerStm_KickerStm))
			
			-- Visible counterparts
			MachineBody_VS_O(id__,cycle_KickerStm_KickerStm) = 
				dbisim((
				let
					finalNodesEntered = {|f0::entered|}
				within
					(dbisim((dbisim((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						i0::enter,
						f0::enter,
						SGoToBall::enter,
						DMovingToBall::enter,
						j0::enter,
						SKick::enter,
						DKicking::enter,
						j1::enter,
						SDribble::enter,
						j2::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited|})
							transSync = {|internal__.NID_i0,internal__.NID_SGoToBall,endexec__.NID_DMovingToBall,internal__.NID_j0,internal__.NID_j0,internal__.NID_SKick,endexec__.NID_DKicking,internal__.NID_j1,internal__.NID_j1,endexec__.NID_SDribble,internal__.NID_j2|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   i0::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   f0::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   SGoToBall::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   DMovingToBall::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   j0::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   SKick::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   DKicking::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   j1::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   SDribble::VS_O__(id__,cycle_KickerStm_KickerStm)
							   [| { share__, terminate } |] (
							   j2::VS_O__(id__,cycle_KickerStm_KickerStm)
							   )
							   )
							   )
							   )
							   )
							   )
							   )
							   )
							   )
							 )
							 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[SGoToBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SGoToBall|}]]
							 [[DMovingToBall::interrupt <- x__ | x__ <- {|interrupt,endexec__.NID_DMovingToBall|}]]
							 [[SKick::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SKick|}]]
							 [[DKicking::interrupt <- x__ | x__ <- {|interrupt,endexec__.NID_DKicking|}]]
							 [[SDribble::interrupt <- x__ | x__ <- {|interrupt,endexec__.NID_SDribble|}]]
							 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
							 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
							 [[j1::interrupt <- x__ | x__ <- {|internal__.NID_j1,internal__.NID_j1|}]]
							 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_kickable <- setL_kickable]]
							 )
							 [| union(union(union(flowevts,transSync),{|terminate,endexec,startexec|}),{|share__
							 			,setL_kickable
							|}) |]
							 ((i0::enter -> Transitions(id__,cycle_KickerStm_KickerStm))
							  [[ share__ <- x__ | x__ <- {| share__,setL_kickable |} ]]
							 )
							)[[setL_kickable <- set_kickable]]
							)
						)
						 \ hideSet)
						[[ endexec__.x____  <- endexec | x____ <- NIDS ]]
						[[ endexec_action <- endexec ]]
						[[ startexec_action <- startexec ]]
					)
					)
					 [| union(stateClockSync,{terminate}) |]
					 StateClocks(id__)
					)\diff(stateClockSync,enteredSS))
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour_VS_O(id__,cycle_KickerStm_KickerStm) = 
				dbisim((let
					stateClockSync = {|get_CLID_SGoToBall,SGoToBall::entered,get_CLID_SKick,SKick::entered,get_CLID_DMovingToBall,DMovingToBall::entered,get_CLID_SDribble,SDribble::entered,get_CLID_DKicking,DKicking::entered|}
				 within
					(MachineBody_VS_O(id__,cycle_KickerStm_KickerStm) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
				)
				)
			
			IteratedBehaviour_VS_O(id__,cycle_KickerStm_KickerStm) = 
				dbisim((let
					stateClockSync = {|get_CLID_SGoToBall,SGoToBall::entered,get_CLID_SKick,SKick::entered,get_CLID_DMovingToBall,DMovingToBall::entered,get_CLID_SDribble,SDribble::entered,get_CLID_DKicking,DKicking::entered|}
				 within
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__,cycle_KickerStm_KickerStm)
															[| {|get_CLID_DKicking,DKicking::entered,terminate|} |]
															dbisim(Clock_CLID_DKicking(id__,0))
														)\{|get_CLID_DKicking|}
													)
													[| {|get_CLID_SDribble,SDribble::entered,terminate|} |]
													dbisim(Clock_CLID_SDribble(id__,0))
												)\{|get_CLID_SDribble|}
											)
											[| {|get_CLID_DMovingToBall,DMovingToBall::entered,terminate|} |]
											dbisim(Clock_CLID_DMovingToBall(id__,0))
										)\{|get_CLID_DMovingToBall|}
									)
									[| {|get_CLID_SKick,SKick::entered,terminate|} |]
									dbisim(Clock_CLID_SKick(id__,0))
								)\{|get_CLID_SKick|}
							)
							[| {|get_CLID_SGoToBall,SGoToBall::entered,terminate|} |]
							dbisim(Clock_CLID_SGoToBall(id__,0))
						)\{|get_CLID_SGoToBall|}
					)
					) \ diff(union(stateClockSync,enteredSS),enteredSS)
				)
				)
			
			Stateful_VS_O(id__,cycle_KickerStm_KickerStm) = 
				dbisim((let
					getsetLocalChannels = {||}
					clockSync = {||}
				within
					(Behaviour_VS_O(id__,cycle_KickerStm_KickerStm) 
					 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
					 (varMemory(id__,cycle_KickerStm_KickerStm) [| {terminate} |] Clocks(id__))
				 	)\union(getsetLocalChannels,clockSync)
				)
				)
			
			IteratedStateful_VS_O(id__,cycle_KickerStm_KickerStm) =
				(IteratedBehaviour_VS_O(id__,cycle_KickerStm_KickerStm))
			
			-- END
			
			-- Memory
			-- Memory variables
			
			-- varMemory process
			varMemory(id__,cycle_KickerStm_KickerStm) = terminate -> SKIP
			
			getsetLocalChannels = {||}
			
			-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			FVS__(id__,cycle_KickerStm_KickerStm) = STM_VS_O(id__,cycle_KickerStm_KickerStm) \ localClockResets
			D__(id__,cycle_KickerStm_KickerStm) = timed_priority(STM(id__,cycle_KickerStm_KickerStm) \ union(internal_events,localClockResets))
			O__(id__,cycle_KickerStm_KickerStm) = dbisim(D__(id__,cycle_KickerStm_KickerStm))
			VS__(id__,cycle_KickerStm_KickerStm) = FVS__(id__,cycle_KickerStm_KickerStm)
			VS_O__(id__,cycle_KickerStm_KickerStm) = dbisim(FVS__(id__,cycle_KickerStm_KickerStm))
			HEXT__(id__,cycle_KickerStm_KickerStm) = O__(id__,cycle_KickerStm_KickerStm) [|shared_variable_events|] SKIP
			FVS_C__(id__,cycle_KickerStm_KickerStm) = dbisim(timed_priority(STM(id__,cycle_KickerStm_KickerStm) \ internal_events))
			HUP__(id__,cycle_KickerStm_KickerStm) = timed_priority(O__(id__,cycle_KickerStm_KickerStm) [|{share__}|] SKIP)
			
			-- Clocks
			
			Clocks(id__) = terminate -> SKIP
			
			clockSync = {||}
			
			Clock_CLID_SGoToBall(id__,x__) = 
				TimeOut_1(
					SGoToBall::entered -> Clock_CLID_SGoToBall(id__,0)
					[]
					get_CLID_SGoToBall!x__ -> Clock_CLID_SGoToBall(id__,x__)
					[]
					terminate -> SKIP,Clock_CLID_SGoToBall(id__,clock_type_plus(x__,1,CLID_SGoToBall_clock_type(id__))))
			Clock_CLID_SKick(id__,x__) = 
				TimeOut_1(
					SKick::entered -> Clock_CLID_SKick(id__,0)
					[]
					get_CLID_SKick!x__ -> Clock_CLID_SKick(id__,x__)
					[]
					terminate -> SKIP,Clock_CLID_SKick(id__,clock_type_plus(x__,1,CLID_SKick_clock_type(id__))))
			Clock_CLID_DMovingToBall(id__,x__) = 
				TimeOut_1(
					DMovingToBall::entered -> Clock_CLID_DMovingToBall(id__,0)
					[]
					get_CLID_DMovingToBall!x__ -> Clock_CLID_DMovingToBall(id__,x__)
					[]
					terminate -> SKIP,Clock_CLID_DMovingToBall(id__,clock_type_plus(x__,1,CLID_DMovingToBall_clock_type(id__))))
			Clock_CLID_SDribble(id__,x__) = 
				TimeOut_1(
					SDribble::entered -> Clock_CLID_SDribble(id__,0)
					[]
					get_CLID_SDribble!x__ -> Clock_CLID_SDribble(id__,x__)
					[]
					terminate -> SKIP,Clock_CLID_SDribble(id__,clock_type_plus(x__,1,CLID_SDribble_clock_type(id__))))
			Clock_CLID_DKicking(id__,x__) = 
				TimeOut_1(
					DKicking::entered -> Clock_CLID_DKicking(id__,0)
					[]
					get_CLID_DKicking!x__ -> Clock_CLID_DKicking(id__,x__)
					[]
					terminate -> SKIP,Clock_CLID_DKicking(id__,clock_type_plus(x__,1,CLID_DKicking_clock_type(id__))))
			
			StateClocks(id__) = dbisim(Clock_CLID_SGoToBall(id__,0))
			[| { terminate } |] (
			dbisim(Clock_CLID_SKick(id__,0))
			[| { terminate } |] (
			dbisim(Clock_CLID_DMovingToBall(id__,0))
			[| { terminate } |] (
			dbisim(Clock_CLID_SDribble(id__,0))
			[| { terminate } |] (
			dbisim(Clock_CLID_DKicking(id__,0))
			)
			)
			)
			)
			
			stateClockSync = {|get_CLID_SGoToBall,SGoToBall::entered,get_CLID_SKick,SKick::entered,get_CLID_DMovingToBall,DMovingToBall::entered,get_CLID_SDribble,SDribble::entered,get_CLID_DKicking,DKicking::entered|}
			
			
			-- Shared memory
			-- Shared memory variables
			Memory_ball(x__) = ( 
				get_ball!x__ -> Memory_ball(x__)
				[]
				registerRead.i_ball?x__ -> Memory_ball(x__)
				[]
				terminate -> SKIP
			)
			Memory_kickable(x__) = ( 
				get_kickable!x__ -> Memory_kickable(x__)
				[]
				registerRead.i_kickable?x__ -> Memory_kickable(x__)
				[]
				terminate -> SKIP
			)
			Memory_kicked(x__) = ( 
				get_kicked!x__ -> Memory_kicked(x__)
				[]
				registerWrite.o_kicked?x__ -> Memory_kicked(x__)
				[]
				terminate -> SKIP
			)
			
			Memory_updateWorldModel(x__) = (
				get_updateWorldModel!x__ -> Memory_updateWorldModel(x__)
				[]
				registerRead.i_updateWorldModel?x__ -> Memory_updateWorldModel(x__)
				[]
				terminate -> SKIP
			)
			
			-- sharedVarMemory process
			sharedVarMemory(id__,cycle_KickerStm_KickerStm) = (
			 (Memory_ball((0,0))
			 [| { terminate } |] (
			 Memory_kickable(true)
			 [| { terminate } |] (
			 Memory_kicked(true)
			 )
			 )
			 )
			 [| { terminate } |]
			 (Memory_updateWorldModel(false)
			 )
			)
			
			sharedVarSync = union({|get_updateWorldModel|},
				  {|get_ball,registerWrite.o_ball,
				  get_kickable,registerWrite.o_kickable,
				  get_kicked,registerWrite.o_kicked|}
				 )
			
			sharedVarHide = union({|get_updateWorldModel|},
				  {|get_ball,
				  get_kickable,
				  get_kicked|}
				 )
			
			}
	endmodule
	
	Timed(OneStep) {
	CALL__doDribble(id__) 	= doDribbleCall -> SKIP
	CALL__canKickToGoal(id__) 	= canKickToGoalCall -> SKIP
	CALL__doKick(id__) 	= doKickCall -> SKIP
	CALL__doMove(id__,
			    param_pos) 	= doMoveCall.param_pos -> SKIP
	CALL__stop(id__) 	= stopCall -> SKIP
	}
	
	Timed(OneStep) {
	-- (Rule 8) cycleController(...) : CSPProcess
	datatype SOutputEvents = SOutput_kicked
		| SOutput_doKick
		| SOutput_doMove
		| SOutput_doDribble
		| SOutput_canKickToGoal
		| SOutput_ball
		| SOutput_stop
		| SOutput_kickable
	
	DVarsEvents = {}
	
	EVarsEvents = {}
	
	cycleController(id__,cycle_Kicker_Kicker) =
	let
				
		project_stm_ref0(stm_ref0::o_kicked.x__) = SOutput_kicked
		project_stm_ref0(stm_ref0::o_doKick) = SOutput_doKick
		project_stm_ref0(stm_ref0::o_doMove.x__) = SOutput_doMove
		project_stm_ref0(stm_ref0::o_doDribble) = SOutput_doDribble
		project_stm_ref0(stm_ref0::o_canKickToGoal) = SOutput_canKickToGoal
		project_stm_ref0(stm_ref0::o_ball.x__) = SOutput_ball
		project_stm_ref0(stm_ref0::o_stop) = SOutput_stop
		project_stm_ref0(stm_ref0::o_kickable.x__) = SOutput_kickable
	
		connected_stm_ref0(stm_ref0::o_kicked.x__) = true
		connected_stm_ref0(stm_ref0::o_doKick) = true
		connected_stm_ref0(stm_ref0::o_doMove.x__) = true
		connected_stm_ref0(stm_ref0::o_doDribble) = true
		connected_stm_ref0(stm_ref0::o_canKickToGoal) = true
		connected_stm_ref0(stm_ref0::o_ball.x__) = true
		connected_stm_ref0(stm_ref0::o_stop) = true
		connected_stm_ref0(stm_ref0::o_kickable.x__) = true
		connected_stm_ref0(_) = false
	
		lift_stm_ref0(stm_ref0::o_kicked.x__) = o_kicked.x__
		lift_stm_ref0(stm_ref0::o_doKick) = o_doKick
		lift_stm_ref0(stm_ref0::o_doMove.x__) = o_doMove.x__
		lift_stm_ref0(stm_ref0::o_doDribble) = o_doDribble
		lift_stm_ref0(stm_ref0::o_canKickToGoal) = o_canKickToGoal
		lift_stm_ref0(stm_ref0::o_ball.x__) = o_ball.x__
		lift_stm_ref0(stm_ref0::o_stop) = o_stop
		lift_stm_ref0(stm_ref0::o_kickable.x__) = o_kickable.x__
		
		CycleController =
			Deadline(
			-- read inputs from the controller and pass to state machines
			(
			((registerRead.i_kicked?x__ ->
				((stm_ref0::registerRead.stm_ref0::i_kicked!x__ -> SKIP)))
				|||
			(registerRead.i_updateWorldModel?x__ ->
				((stm_ref0::registerRead.stm_ref0::i_updateWorldModel!x__ -> SKIP)))
				|||
			(registerRead.i_ball?x__ ->
				((stm_ref0::registerRead.stm_ref0::i_ball!x__ -> SKIP)))
				|||
			(registerRead.i_kickable?x__ ->
				((stm_ref0::registerRead.stm_ref0::i_kickable!x__ -> SKIP))))
			-- ensure state machines read the values being communicated via evars
					);
			-- synchronize on events related to evars to erase memory
			-- collect outputs, and monitor termination of the cycle, by all controllers
			(CollectOutputs(SOutputEvents) [| {endexec} |] Monitor),0);
			-- wait for the cycleDef period
			TimeOut_1(terminate -> SKIP,WAIT(cycle_Kicker_Kicker-1));
			-- recurse
			CycleController
			
									
		CollectOutputs(sout) =
			(stm_ref0::registerWrite?outp:{ outp | outc <- diff(sout,union(EVarsEvents,DVarsEvents)), outp <- stm_ref0::RegisterDataOutput, connected_stm_ref0(outp), project_stm_ref0(outp) == outc}
					-> registerWrite!lift_stm_ref0(outp)
						-> CollectOutputs(diff(sout,{project_stm_ref0(outp)}))
			[]
			endexec -> SKIP
			)
	
		Monitor = 
			(	 (stm_ref0::endexec -> SKIP)); endexec -> SKIP
	within
		CycleController
	
	-- (Rule 5) memoryComp(...) : CSPProcess
	memoryComp(id__) = (
		STOP)
	
	
	-- (Rule 7) [[ c : Controller ]]_C : CSPProcess
	D__(id__,cycle_Kicker_Kicker) =
	timed_priority(
		(
			(
				(
					(
					dbisim(cycleController(id__,cycle_Kicker_Kicker))
				 	 [| Union({{||},
				 	 		  {||},
				 	 		  {||},
				 	 		  {||}}) |]
				 	memoryComp(id__)
				 	)\{||}
					[| {| 	terminate,tock,
							stm_ref0::endexec,stm_ref0::registerRead,stm_ref0::registerWrite|} |]
					-- (Rule 9) composeMachines(...) : CSPProcess
				 	((let
				 		cycle_KickerStm_KickerStm = cycle_Kicker_Kicker
				 	within
				 		(stm_ref0::D__(id__,cycle_KickerStm_KickerStm)
				 		\{| |})
				 		[[stm_ref0::terminate <- terminate]]
				 	)
				 	)
				) \ {|	stm_ref0::endexec,stm_ref0::registerRead,stm_ref0::registerWrite |}
			) [| {terminate} |> SKIP
		)
	)
	
	O__(id__,cycle_Kicker_Kicker) = 
	timed_priority(
		dbisim(
			(
				(
					(
					dbisim(cycleController(id__,cycle_Kicker_Kicker))
				 	 [| Union({{||},
				 	 		  {||},
				 	 		  {||},
				 	 		  {||}}) |]
				 	memoryComp(id__)
				 	)\{||}
					[| {| 	terminate,tock,
							stm_ref0::endexec,stm_ref0::registerRead,stm_ref0::registerWrite|} |]
					-- (Rule 9) composeMachines(...) : CSPProcess
				 	((let
				 		cycle_KickerStm_KickerStm = cycle_Kicker_Kicker
				 	within
				 		(stm_ref0::O__(id__,cycle_KickerStm_KickerStm)
				 		\{| |})
				 		[[stm_ref0::terminate <- terminate]]
				 	)
				 	)
				) \ {|	stm_ref0::endexec,stm_ref0::registerRead,stm_ref0::registerWrite |}
			) [| {terminate} |> SKIP
		)
	)
	}
endmodule
